// Autogenerated file. To regenerate, please run `FIX_TESTS=1 cargo test
// test_fibonacci_rust_codegen`.

use super::ops::*;
use crate::core::fields::m31::M31;
pub struct Input {
    pub values: Vec<u16>,
}
pub struct Output {
    pub unpacked: Vec<M31>,
}
pub fn compute(input: &Input) -> Output {
    let values = &input.values;
    let mut unpacked = Vec::<M31>::with_capacity(1024);
    unsafe {
        unpacked.set_len(1024);
    }
    for i in 0..64 {
        let value_shr_0 = values[i * 1 + 0];
        let one: u16 = const_val(1 as u16);
        let value_shr_1: u16 = shr(value_shr_0, one);
        let value_shr_2: u16 = shr(value_shr_1, one);
        let value_shr_3: u16 = shr(value_shr_2, one);
        let value_shr_4: u16 = shr(value_shr_3, one);
        let value_shr_5: u16 = shr(value_shr_4, one);
        let value_shr_6: u16 = shr(value_shr_5, one);
        let value_shr_7: u16 = shr(value_shr_6, one);
        let value_shr_8: u16 = shr(value_shr_7, one);
        let value_shr_9: u16 = shr(value_shr_8, one);
        let value_shr_10: u16 = shr(value_shr_9, one);
        let value_shr_11: u16 = shr(value_shr_10, one);
        let value_shr_12: u16 = shr(value_shr_11, one);
        let value_shr_13: u16 = shr(value_shr_12, one);
        let value_shr_14: u16 = shr(value_shr_13, one);
        let value_shr_15: u16 = shr(value_shr_14, one);
        let m31_value_shr_0: M31 = M31::from(value_shr_0);
        let m31_value_shr_1: M31 = M31::from(value_shr_1);
        let m31_value_shr_2: M31 = M31::from(value_shr_2);
        let m31_value_shr_3: M31 = M31::from(value_shr_3);
        let m31_value_shr_4: M31 = M31::from(value_shr_4);
        let m31_value_shr_5: M31 = M31::from(value_shr_5);
        let m31_value_shr_6: M31 = M31::from(value_shr_6);
        let m31_value_shr_7: M31 = M31::from(value_shr_7);
        let m31_value_shr_8: M31 = M31::from(value_shr_8);
        let m31_value_shr_9: M31 = M31::from(value_shr_9);
        let m31_value_shr_10: M31 = M31::from(value_shr_10);
        let m31_value_shr_11: M31 = M31::from(value_shr_11);
        let m31_value_shr_12: M31 = M31::from(value_shr_12);
        let m31_value_shr_13: M31 = M31::from(value_shr_13);
        let m31_value_shr_14: M31 = M31::from(value_shr_14);
        let m31_value_shr_15: M31 = M31::from(value_shr_15);
        unpacked[i * 16 + 0] = m31_value_shr_0;
        unpacked[i * 16 + 1] = m31_value_shr_1;
        unpacked[i * 16 + 2] = m31_value_shr_2;
        unpacked[i * 16 + 3] = m31_value_shr_3;
        unpacked[i * 16 + 4] = m31_value_shr_4;
        unpacked[i * 16 + 5] = m31_value_shr_5;
        unpacked[i * 16 + 6] = m31_value_shr_6;
        unpacked[i * 16 + 7] = m31_value_shr_7;
        unpacked[i * 16 + 8] = m31_value_shr_8;
        unpacked[i * 16 + 9] = m31_value_shr_9;
        unpacked[i * 16 + 10] = m31_value_shr_10;
        unpacked[i * 16 + 11] = m31_value_shr_11;
        unpacked[i * 16 + 12] = m31_value_shr_12;
        unpacked[i * 16 + 13] = m31_value_shr_13;
        unpacked[i * 16 + 14] = m31_value_shr_14;
        unpacked[i * 16 + 15] = m31_value_shr_15;
    }
    Output { unpacked }
}
