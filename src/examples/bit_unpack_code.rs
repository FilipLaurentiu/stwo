// Autogenerated file. To regenerate, please run `FIX_TESTS=1 cargo test
// test_fibonacci_rust_codegen`.

use super::ops::*;
use crate::core::fields::m31::M31;
use crate::core::fields::qm31::QM31;
pub struct Input {
    pub values: Vec<u16>,
    pub random_element: Vec<QM31>,
}
pub struct Output {
    pub unpacked: Vec<M31>,
    pub rc_logup_num: Vec<QM31>,
    pub rc_logup_denom: Vec<QM31>,
}
pub fn compute(input: &Input) -> Output {
    let values = &input.values;
    let random_element = &input.random_element;
    let mut unpacked = Vec::<M31>::with_capacity(1024);
    unsafe {
        unpacked.set_len(1024);
    }
    let mut rc_logup_num = Vec::<QM31>::with_capacity(1024);
    unsafe {
        rc_logup_num.set_len(1024);
    }
    let mut rc_logup_denom = Vec::<QM31>::with_capacity(1024);
    unsafe {
        rc_logup_denom.set_len(1024);
    }
    for i in 0..64 {
        let value_shr_0 = values[i * 1 + 0];
        let one: u16 = const_val(1 as u16);
        let value_shr_1: u16 = shr(value_shr_0, one);
        let value_shr_2: u16 = shr(value_shr_1, one);
        let value_shr_3: u16 = shr(value_shr_2, one);
        let value_shr_4: u16 = shr(value_shr_3, one);
        let value_shr_5: u16 = shr(value_shr_4, one);
        let value_shr_6: u16 = shr(value_shr_5, one);
        let value_shr_7: u16 = shr(value_shr_6, one);
        let value_shr_8: u16 = shr(value_shr_7, one);
        let value_shr_9: u16 = shr(value_shr_8, one);
        let value_shr_10: u16 = shr(value_shr_9, one);
        let value_shr_11: u16 = shr(value_shr_10, one);
        let value_shr_12: u16 = shr(value_shr_11, one);
        let value_shr_13: u16 = shr(value_shr_12, one);
        let value_shr_14: u16 = shr(value_shr_13, one);
        let value_shr_15: u16 = shr(value_shr_14, one);
        let m31_value_shr_0: M31 = M31::from(value_shr_0);
        let m31_value_shr_1: M31 = M31::from(value_shr_1);
        let m31_value_shr_2: M31 = M31::from(value_shr_2);
        let m31_value_shr_3: M31 = M31::from(value_shr_3);
        let m31_value_shr_4: M31 = M31::from(value_shr_4);
        let m31_value_shr_5: M31 = M31::from(value_shr_5);
        let m31_value_shr_6: M31 = M31::from(value_shr_6);
        let m31_value_shr_7: M31 = M31::from(value_shr_7);
        let m31_value_shr_8: M31 = M31::from(value_shr_8);
        let m31_value_shr_9: M31 = M31::from(value_shr_9);
        let m31_value_shr_10: M31 = M31::from(value_shr_10);
        let m31_value_shr_11: M31 = M31::from(value_shr_11);
        let m31_value_shr_12: M31 = M31::from(value_shr_12);
        let m31_value_shr_13: M31 = M31::from(value_shr_13);
        let m31_value_shr_14: M31 = M31::from(value_shr_14);
        let m31_value_shr_15: M31 = M31::from(value_shr_15);
        unpacked[i * 16 + 0] = m31_value_shr_0;
        unpacked[i * 16 + 1] = m31_value_shr_1;
        unpacked[i * 16 + 2] = m31_value_shr_2;
        unpacked[i * 16 + 3] = m31_value_shr_3;
        unpacked[i * 16 + 4] = m31_value_shr_4;
        unpacked[i * 16 + 5] = m31_value_shr_5;
        unpacked[i * 16 + 6] = m31_value_shr_6;
        unpacked[i * 16 + 7] = m31_value_shr_7;
        unpacked[i * 16 + 8] = m31_value_shr_8;
        unpacked[i * 16 + 9] = m31_value_shr_9;
        unpacked[i * 16 + 10] = m31_value_shr_10;
        unpacked[i * 16 + 11] = m31_value_shr_11;
        unpacked[i * 16 + 12] = m31_value_shr_12;
        unpacked[i * 16 + 13] = m31_value_shr_13;
        unpacked[i * 16 + 14] = m31_value_shr_14;
        unpacked[i * 16 + 15] = m31_value_shr_15;
    }
    for i in 0..1 {
        let m31_unpacked0 = unpacked[i * 1 + 0];
        let random_element0 = random_element[(i * 1 + 0) % 1];
        let rc_logup_num0: QM31 = QM31::from([1, 0, 0, 0]);
        let unpacked0: QM31 = QM31::from(m31_unpacked0);
        let shifted_unpacked0: QM31 = sub(unpacked0, random_element0);
        rc_logup_num[i * 1 + 0] = rc_logup_num0;
        rc_logup_denom[i * 1 + 0] = shifted_unpacked0;
    }
    for i in 0..1023 {
        let random_element0 = random_element[(i * 1 + 0) % 1];
        let m31_unpacked_curr = unpacked[i * 1 + 1];
        let rc_logup_num_curr = rc_logup_num[i * 1 + 0];
        let rc_logup_denom_curr = rc_logup_denom[i * 1 + 0];
        let unpacked_curr: QM31 = QM31::from(m31_unpacked_curr);
        let shifted_unpacked: QM31 = sub(unpacked_curr, random_element0);
        let rc_logup_denom_next: QM31 = mul(rc_logup_denom_curr, shifted_unpacked);
        let rc_logup_num_temp: QM31 = mul(rc_logup_num_curr, shifted_unpacked);
        let rc_logup_num_next: QM31 = add(rc_logup_num_temp, rc_logup_denom_curr);
        rc_logup_num[i * 1 + 1] = rc_logup_num_next;
        rc_logup_denom[i * 1 + 1] = rc_logup_denom_next;
    }
    Output {
        unpacked,
        rc_logup_num,
        rc_logup_denom,
    }
}
